type: edu
files:
- name: hyperjob/__init__.py
  visible: true
  learner_created: false
- name: hyperjob/settings.py
  visible: true
  text: |
    """
    Django settings for hyperjob project.

    Generated by 'django-admin startproject' using Django 2.2.6.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/2.2/ref/settings/
    """

    import os

    # Build paths inside the project like this: os.path.join(BASE_DIR, ...)
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = '*57#^8!%%x4wi6byh%qj3!&7b)qu5ve7m5tz9&)2^jievj2j1b'

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = []


    # Application definition

    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'resume',
        'vacancy',
    ]

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'hyperjob.urls'

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

    WSGI_APPLICATION = 'hyperjob.wsgi.application'


    # Database
    # https://docs.djangoproject.com/en/2.2/ref/settings/#databases

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.environ.get('HYPERSKILL_TEST_DATABASE') or os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }

    # Password validation
    # https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/2.2/topics/i18n/

    LANGUAGE_CODE = 'en-us'

    TIME_ZONE = 'UTC'

    USE_I18N = True

    USE_L10N = True

    USE_TZ = True


    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/2.2/howto/static-files/

    STATIC_URL = '/static/'
  learner_created: false
- name: hyperjob/urls.py
  visible: true
  text: |
    """hyperjob URL Configuration

    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/2.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path

    urlpatterns = [
        path('admin/', admin.site.urls),
    ]
  learner_created: false
- name: hyperjob/wsgi.py
  visible: true
  text: |
    """
    WSGI config for hyperjob project.

    It exposes the WSGI callable as a module-level variable named ``application``.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/
    """

    import os

    from django.core.wsgi import get_wsgi_application

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hyperjob.settings')

    application = get_wsgi_application()
  learner_created: false
- name: resume/migrations/__init__.py
  visible: true
  learner_created: false
- name: resume/__init__.py
  visible: true
  learner_created: false
- name: resume/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: resume/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class ResumeConfig(AppConfig):
        name = 'resume'
  learner_created: false
- name: resume/models.py
  visible: true
  text: |
    from django.db import models

    # Create your models here.
  learner_created: false
- name: resume/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: resume/views.py
  visible: true
  text: |
    from django.shortcuts import render

    # Create your views here.
  learner_created: false
- name: vacancy/migrations/__init__.py
  visible: true
  learner_created: false
- name: vacancy/__init__.py
  visible: true
  learner_created: false
- name: vacancy/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: vacancy/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class VacancyConfig(AppConfig):
        name = 'vacancy'
  learner_created: false
- name: vacancy/models.py
  visible: true
  text: |
    from django.db import models

    # Create your models here.
  learner_created: false
- name: vacancy/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: vacancy/views.py
  visible: true
  text: |
    from django.shortcuts import render

    # Create your views here.
  learner_created: false
- name: manage.py
  visible: true
  text: |
    #!/usr/bin/env python
    """Django's command-line utility for administrative tasks."""
    import os
    import sys


    def main():
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hyperjob.settings')
        try:
            from django.core.management import execute_from_command_line
        except ImportError as exc:
            raise ImportError(
                "Couldn't import Django. Are you sure it's installed and "
                "available on your PYTHONPATH environment variable? Did you "
                "forget to activate a virtual environment?"
            ) from exc
        execute_from_command_line(sys.argv)


    if __name__ == '__main__':
        main()
  learner_created: false
- name: test/__init__.py
  visible: false
  learner_created: false
- name: test/base.py
  visible: false
  text: "import http.cookiejar\nimport re\nimport sqlite3\nimport urllib\nimport urllib.error\n\
    import urllib.parse\nimport urllib.request\n\nfrom hstest import CheckResult,\
    \ DjangoTest\n\nINITIAL_USERS = [\n    (1, 'Lemon_2059', 'contemp2015@protonmail.com',\
    \ True),\n    (2, 'RuthlessnessSirens-1882', 'oversured1842@yahoo.com', True),\n\
    \    (3, 'moping_1935', 'tenons1970@outlook.com', True),\n    (4, 'MillagePenstemon-1843',\
    \ 'chrisman1923@yandex.com', True),\n    (5, 'Archeus.1930', 'concentric1895@gmail.com',\
    \ True),\n    (6, 'BenzalazineCurite.1832', 'quassiin1927@live.com', True),\n\
    \    (7, 'Bossa-1831', 'breena1977@live.com', False),\n    (8, 'ClinkChinho_2027',\
    \ 'adansonia1808@gmail.com', False),\n    (9, 'RepassableTournefortian.1973',\
    \ 'vomer1822@yahoo.com', False),\n    (10, 'debenture-1898', 'average2014@yahoo.com',\
    \ False),\n]\n\nINITIAL_VACANCIES = [\n    (1, 'Botanist'),\n    (2, 'Signwriter'),\n\
    \    (3, 'Stewardess'),\n    (4, 'Medical Secretary'),\n    (5, 'Stone Cutter'),\n\
    \    (6, 'Musician'),\n]\n\nINITIAL_RESUMES = [\n    (7, 'Charge Hand'),\n   \
    \ (8, 'Occupations'),\n    (9, 'Milklady'),\n    (10, 'Auctioneer'),\n]\n\n\n\
    class HyperJobTest(DjangoTest):\n\n    use_database = True\n\n    USERNAME = 'Sparrow_1949'\n\
    \    PASSWORD = 's<myW8Dh'\n    OCCUPATION = 'Flower Arranger'\n\n    ELEMENT_PATTERN\
    \ = '''<a[^>]+href=['\"](?P<href>[a-zA-Z/_]+)['\"][^>]*>'''\n    cookie_jar =\
    \ http.cookiejar.CookieJar()\n\n    def check_create_resume_from_profile(self)\
    \ -> CheckResult:\n        opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))\n\
    \        try:\n            response = opener.open(self.get_url() + 'home')\n \
    \       except urllib.error.URLError:\n            return CheckResult.wrong('Cannot\
    \ connect to the home page.')\n\n        csrf_options = re.findall(\n        \
    \    b'<input[^>]+value=\"(?P<csrf>\\\\w+)\"[^>]*>', response.read()\n       \
    \ )\n        if not csrf_options:\n            return CheckResult.wrong('Missing\
    \ csrf_token in the form')\n\n        try:\n            response = opener.open(\n\
    \                f'{self.get_url()}resume/new',\n                data=urllib.parse.urlencode({\n\
    \                    'description': self.OCCUPATION,\n                    'csrfmiddlewaretoken':\
    \ csrf_options[0],\n                }).encode()\n            )\n        except\
    \ urllib.error.URLError as err:\n            return CheckResult.wrong(f'Cannot\
    \ create resume: {err.reason}')\n\n        try:\n            page = self.read_page(f'{self.get_url()}resumes')\n\
    \            description = f'{self.USERNAME}: {self.OCCUPATION}'\n           \
    \ if description not in page:\n                return CheckResult.wrong(\n   \
    \                 f'Resumes page does not contain newly created resume'\n    \
    \            )\n            return CheckResult.correct()\n        except urllib.error.URLError:\n\
    \            return CheckResult.wrong('Cannot connect to the resumes page.')\n\
    \n    def check_create_resumes(self) -> CheckResult:\n        connection = sqlite3.connect(self.attach.test_database)\n\
    \        cursor = connection.cursor()\n        try:\n            cursor.executemany(\n\
    \                'INSERT INTO auth_user '\n                '(`id`, `username`,\
    \ `email`, `is_staff`, `password`, `is_superuser`, '\n                '`first_name`,\
    \ `last_name`, `is_active`, `date_joined`) '\n                'VALUES (?, ?, ?,\
    \ ?, \"\", 0, \"\", \"\", 1, datetime())',\n                INITIAL_USERS[len(INITIAL_VACANCIES):]\n\
    \            )\n            cursor.executemany(\n                'INSERT INTO\
    \ resume_resume (`author_id`, `description`) VALUES (?, ?)',\n               \
    \ INITIAL_RESUMES\n            )\n            connection.commit()\n\n        \
    \    cursor.execute('SELECT `author_id`, `description` FROM resume_resume')\n\
    \            result = cursor.fetchall()\n\n            for item in INITIAL_RESUMES:\n\
    \                if item not in result:\n                    return CheckResult.wrong('Check\
    \ your Resume model')\n            return CheckResult.correct()\n\n        except\
    \ sqlite3.DatabaseError as err:\n            return CheckResult.wrong(str(err))\n\
    \n    def check_create_vacancies(self) -> CheckResult:\n        connection = sqlite3.connect(self.attach.test_database)\n\
    \        cursor = connection.cursor()\n        try:\n            cursor.executemany(\n\
    \                'INSERT INTO auth_user '\n                '(`id`, `username`,\
    \ `email`, `is_staff`, `password`, `is_superuser`, '\n                '`first_name`,\
    \ `last_name`, `is_active`, `date_joined`) '\n                'VALUES (?, ?, ?,\
    \ ?, \"\", 0, \"\", \"\", 1, datetime())',\n                INITIAL_USERS[:len(INITIAL_VACANCIES)]\n\
    \            )\n            cursor.executemany(\n                'INSERT INTO\
    \ vacancy_vacancy (`author_id`, `description`) VALUES (?, ?)',\n             \
    \   INITIAL_VACANCIES\n            )\n            connection.commit()\n\n    \
    \        cursor.execute('SELECT `author_id`, `description` FROM vacancy_vacancy')\n\
    \            result = cursor.fetchall()\n\n            for item in INITIAL_VACANCIES:\n\
    \                if item not in result:\n                    return CheckResult.wrong('Check\
    \ your Vacancy model')\n            return CheckResult.correct()\n\n        except\
    \ sqlite3.DatabaseError as err:\n            return CheckResult.wrong(str(err))\n\
    \n    def check_forbid_anonymous_create(self) -> CheckResult:\n        opener\
    \ = urllib.request.build_opener()\n        try:\n            response = opener.open(f'{self.get_url()}home')\n\
    \        except urllib.error.URLError:\n            return CheckResult.wrong('Cannot\
    \ connect to the home page.')\n\n        csrf_options = re.findall(\n        \
    \    b'<input[^>]+value=\"(?P<csrf>\\\\w+)\"[^>]*>', response.read()\n       \
    \ )\n        if not csrf_options:\n            return CheckResult.correct()\n\n\
    \        OTHER_OCCUPATION = 'Marketing Coordinator'\n\n        try:\n        \
    \    response = opener.open(\n                f'{self.get_url()}resume/new',\n\
    \                data=urllib.parse.urlencode({\n                    'description':\
    \ OTHER_OCCUPATION,\n                    'csrfmiddlewaretoken': csrf_options[0],\n\
    \                }).encode()\n            )\n            return CheckResult.wrong('Should\
    \ not allow anonymous users create resumes')\n        except urllib.error.URLError\
    \ as err:\n            if 'Forbidden' not in err.reason:\n                return\
    \ CheckResult.wrong(f'Wrong response for forbidden requests: {err.reason}')\n\n\
    \        try:\n            page = self.read_page(f'{self.get_url()}resumes')\n\
    \            if OTHER_OCCUPATION in page:\n                return CheckResult.wrong(\n\
    \                    f'Resumes page should not contain resumes from anonymous\
    \ users'\n                )\n            return CheckResult.correct()\n      \
    \  except urllib.error.URLError:\n            return CheckResult.wrong('Cannot\
    \ connect to the resumes page.')\n\n    def check_forbid_to_create_vacancy(self)\
    \ -> CheckResult:\n        opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))\n\
    \        try:\n            response = opener.open(f'{self.get_url()}home')\n \
    \       except urllib.error.URLError:\n            return CheckResult.wrong('Cannot\
    \ connect to the home page.')\n\n        csrf_options = re.findall(\n        \
    \    b'<input[^>]+value=\"(?P<csrf>\\\\w+)\"[^>]*>', response.read()\n       \
    \ )\n        if not csrf_options:\n            return CheckResult.correct()\n\n\
    \        OTHER_OCCUPATION = 'Marketing Coordinator'\n\n        try:\n        \
    \    response = opener.open(\n                f'{self.get_url()}vacancy/new',\n\
    \                data=urllib.parse.urlencode({\n                    'description':\
    \ OTHER_OCCUPATION,\n                    'csrfmiddlewaretoken': csrf_options[0],\n\
    \                }).encode()\n            )\n            return CheckResult.wrong('Should\
    \ not allow usual users create vacancies')\n        except urllib.error.URLError\
    \ as err:\n            if 'Forbidden' not in err.reason:\n                return\
    \ CheckResult.wrong(f'Wrong response for forbidden requests: {err.reason}')\n\n\
    \        try:\n            page = self.read_page(f'{self.get_url()}vacancies')\n\
    \            if OTHER_OCCUPATION in page:\n                return CheckResult.wrong(\n\
    \                    f'Vacancies page should not contain vacancies from usual\
    \ users'\n                )\n            return CheckResult.correct()\n      \
    \  except urllib.error.URLError:\n            return CheckResult.wrong('Cannot\
    \ connect to the vacancies page.')\n\n    def check_greeting(self) -> CheckResult:\n\
    \        try:\n            main_page = self.read_page(self.get_url())\n      \
    \      if 'Welcome to HyperJob!' in main_page:\n                return CheckResult.correct()\n\
    \            return CheckResult.wrong(\n                'Main page should contain\
    \ \"Welcome to HyperJob!\" line'\n            )\n        except urllib.error.URLError:\n\
    \            return CheckResult.wrong(\n                'Cannot connect to the\
    \ menu page.'\n            )\n\n    def check_links(self) -> CheckResult:\n  \
    \      try:\n            page = self.read_page(self.get_url())\n            links\
    \ = re.findall(self.ELEMENT_PATTERN, page)\n            for link in (\n      \
    \          '/login',\n                '/logout',\n                '/signup',\n\
    \                '/vacancies',\n                '/resumes',\n                '/home',\n\
    \            ):\n                if link not in links:\n                    return\
    \ CheckResult.wrong(\n                        f'Menu page should contain <a> element\
    \ with href {link}'\n                    )\n            return CheckResult.correct()\n\
    \        except urllib.error.URLError:\n            return CheckResult.wrong(\n\
    \                'Cannot connect to the menu page.'\n            )\n\n    def\
    \ check_login(self) -> CheckResult:\n        opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))\n\
    \        try:\n            response = opener.open(f'{self.get_url()}login')\n\
    \        except urllib.error.URLError:\n            return CheckResult.wrong('Cannot\
    \ connect to the login page.')\n\n        csrf_options = re.findall(\n       \
    \     b'<input[^>]+value=\"(?P<csrf>\\\\w+)\"[^>]*>', response.read()\n      \
    \  )\n        if not csrf_options:\n            return CheckResult.wrong('Missing\
    \ csrf_token in the form')\n\n        try:\n            response = opener.open(\n\
    \                f'{self.get_url()}login',\n                data=urllib.parse.urlencode({\n\
    \                    'csrfmiddlewaretoken': csrf_options[0],\n               \
    \     'username': self.USERNAME,\n                    'password': self.PASSWORD,\n\
    \                }).encode()\n            )\n            if 'login' not in response.url:\n\
    \                return CheckResult.correct()\n            return CheckResult.wrong('Cannot\
    \ login: problems with form')\n        except urllib.error.URLError as err:\n\
    \            return CheckResult.wrong(f'Cannot login: {err.reason}')\n\n    def\
    \ check_logout(self) -> CheckResult:\n        opener = urllib.request.build_opener()\n\
    \        try:\n            opener.open(f'{self.get_url()}logout')\n          \
    \  return CheckResult.correct()\n        except urllib.error.URLError:\n     \
    \       return CheckResult.wrong('Cannot connect to the logout page.')\n    \n\
    \n    def check_resumes(self) -> CheckResult:\n        try:\n            page\
    \ = self.read_page(f'{self.get_url()}resumes')\n            for person, resume\
    \ in zip(INITIAL_USERS[len(INITIAL_VACANCIES):], INITIAL_RESUMES):\n         \
    \       description = f'{person[1]}: {resume[1]}'\n                if description\
    \ not in page:\n                    return CheckResult.wrong(\n              \
    \          f'Resumes page should contain resumes in form <username>: <description>'\n\
    \                    )\n            return CheckResult.correct()\n        except\
    \ urllib.error.URLError:\n            return CheckResult.wrong(\n            \
    \    'Cannot connect to the resumes page.'\n            )\n\n    def check_signup(self)\
    \ -> CheckResult:\n        opener = urllib.request.build_opener(\n           \
    \ urllib.request.HTTPCookieProcessor(self.cookie_jar)\n        )\n        try:\n\
    \            response = opener.open(f'{self.get_url()}signup')\n        except\
    \ urllib.error.URLError:\n            return CheckResult.wrong('Cannot connect\
    \ to the signup page.')\n\n        csrf_options = re.findall(\n            b'<input[^>]+value=\"\
    (?P<csrf>\\\\w+)\"[^>]*>', response.read()\n        )\n        if not csrf_options:\n\
    \            return CheckResult.wrong('Missing csrf_token in the form')\n\n  \
    \      try:\n            response = opener.open(\n                f'{self.get_url()}signup',\n\
    \                data=urllib.parse.urlencode({\n                    'csrfmiddlewaretoken':\
    \ csrf_options[0],\n                    'username': self.USERNAME,\n         \
    \           'password1': self.PASSWORD,\n                    'password2': self.PASSWORD,\n\
    \                }).encode()\n            )\n            if f'login' in response.url:\n\
    \                return CheckResult.correct()\n            return CheckResult.wrong('Cannot\
    \ signup: problems with form')\n        except urllib.error.URLError as err:\n\
    \            return CheckResult.wrong(f'Cannot signup: {err.reason}')\n\n    def\
    \ check_vacancies(self) -> CheckResult:\n        try:\n            page = self.read_page(f'{self.get_url()}vacancies')\n\
    \            for person, vacancy in zip(INITIAL_USERS, INITIAL_VACANCIES):\n \
    \               description = f'{person[1]}: {vacancy[1]}'\n                if\
    \ description not in page:\n                    return CheckResult.wrong(\n  \
    \                      f'Vacancies page should contain vacancies in form <username>:\
    \ <description>'\n                    )\n            return CheckResult.correct()\n\
    \        except urllib.error.URLError:\n            return CheckResult.wrong(\n\
    \                'Cannot connect to the vacancies page.'\n            )\n"
  learner_created: false
- name: test/tests.py
  visible: false
  text: |
    from hstest import dynamic_test

    from .base import HyperJobTest


    class HyperJobTestRunner(HyperJobTest):

        funcs = [
            # 1 task
            HyperJobTest.check_create_vacancies,
            HyperJobTest.check_create_resumes,
            # 2 task
            HyperJobTest.check_greeting,
            HyperJobTest.check_links,
            # 3 task
            HyperJobTest.check_vacancies,
            HyperJobTest.check_resumes,
            # 4 task
            HyperJobTest.check_signup,
            HyperJobTest.check_login,
            HyperJobTest.check_logout,
        ]

        @dynamic_test(data=funcs)
        def test(self, func):
            return func(self)


    if __name__ == '__main__':
        HyperJobTestRunner().run_tests()
  learner_created: false
- name: tests.py
  visible: false
  text: |
    from test.tests import HyperJobTestRunner

    if __name__ == '__main__':
        HyperJobTestRunner().run_tests()
  learner_created: false
- name: vacancy/templates/vacancy/vacancy.html
  visible: true
  text: |-
    {% extends 'vacancy/base.html' %}

    {% block header %} <h1> Vacancies </h1> {% endblock %}
    {% block title %} <title> Vacancies </title> {% endblock %}
    {% block content %}

    {% for item in data %}
    <div>
        {{item.author}}: {{item.description}}

    </div>
    {% endfor %}
    {% endblock %}
  learner_created: true
- name: vacancy/urls.py
  visible: true
  text: |
    from django.urls import path
    from .views import VacancyMenu, VacancyList

    # app_name = "vacancy"

    urlpatterns = [
        path("", VacancyMenu.as_view()),
        path("vacancies", VacancyList.as_view())
    ]
  learner_created: true
- name: resume/templates/resume/base.html
  visible: true
  text: |-
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        {% block title %} {% endblock %}
    </head>
    <body>
    {% block header %} {% endblock %}
    {% block content %}
    {% endblock %}

    </body>
    </html>
  learner_created: true
- name: resume/templates/resume/resume.html
  visible: true
  text: |-
    {% extends 'resume/base.html' %}

    {% block title %} <title> Resume </title> {% endblock %}
    {% block header %} <h1> Resume </h1> {% endblock %}
    {% block content %}

    {% for item in data %}
    <div>
        {{item.author}}: {{item.description}}

    </div>
    {% endfor %}
    {% endblock %}
  learner_created: true
- name: vacancy/templates/vacancy/menu.html
  visible: true
  text: |-
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>HyperJob Agency</title>
    </head>
    <body>
    <h2>Welcome to HyperJob!</h2>
    <p><a href="/login">Login</a></p>
    <p><a href="/logout">Logout</a></p>
    <p><a href="/signup">Signup</a></p>
    <p><a href="/vacancies">Vacancies</a></p>
    <p><a href="/resumes">Resume</a></p>
    <p><a href="/home">Personal profile</a></p>
    </body>
    </html>
  learner_created: true
- name: vacancy/migrations/0001_initial.py
  visible: true
  text: |
    # Generated by Django 2.2 on 2023-02-09 00:00

    from django.conf import settings
    from django.db import migrations, models
    import django.db.models.deletion


    class Migration(migrations.Migration):

        initial = True

        dependencies = [
            migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ]

        operations = [
            migrations.CreateModel(
                name='Vacancy',
                fields=[
                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('description', models.TextField(max_length=1024)),
                    ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ],
            ),
        ]
  learner_created: true
- name: resume/migrations/0001_initial.py
  visible: true
  text: |
    # Generated by Django 2.2 on 2023-02-09 00:00

    from django.conf import settings
    from django.db import migrations, models
    import django.db.models.deletion


    class Migration(migrations.Migration):

        initial = True

        dependencies = [
            migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ]

        operations = [
            migrations.CreateModel(
                name='Resume',
                fields=[
                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('description', models.TextField(max_length=1024)),
                    ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ],
            ),
        ]
  learner_created: true
- name: resume/urls.py
  visible: true
  text: |+
    from django.urls import path
    from .views import ResumeMenu, ResumeList

    # app_name = "resume"

    urlpatterns = [
        path("new", ResumeMenu.as_view()),
        path("resumes", ResumeList.as_view())
    ]

  learner_created: true
- name: hyperjob/views.py
  visible: true
  learner_created: true
- name: hyperjob/templates/hyperjob/__init__.py
  visible: true
  learner_created: true
- name: hyperjob/templates/hyperjob/login.html
  visible: true
  learner_created: true
- name: hyperjob/templates/hyperjob/logout.html
  visible: true
  learner_created: true
- name: hyperjob/templates/hyperjob/signup.html
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/94/stages/522/implement#comment
status: Solved
feedback:
  message: Congratulations!
  time: "Sat, 11 Feb 2023 03:41:20 UTC"
record: 4
